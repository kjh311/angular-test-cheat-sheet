# ANGULARJS
This test measures the Web developer's knowledge of AngularJS, or Angular. It covers general knowledge
of the Web application framework, which was released by Google. It also covers HTML5 and JavaScript.
The Secure Evaluation Mode and Remote versions of this test will contain a minimum of 54 questions and
will require a typical time of 64 minutes. The Secure Interview Mode and QwikChek versions will provide
as many questions as the test taker can answer within an approximate 40 minute time limit.
Following is a description of each sub-topic on the test:

# Defining Custom Objects determines proficiency in extending the JavaScript object model with userdeveloped objects. Measures knowledge and understanding of prototypal inheritance, as well as variables lifecycle inside objects (scope and context).
-

In real life, a car is an object.

A car has properties like weight and color, and methods like start and stop:

Properties

- car.name = Fiat
- car.model = 500
- car.weight = 850kg
- car.color = white

Methods

- car.start()
- car.drive()
- car.brake()
- car.stop()

CREATING OBJECTS:

Object literal:

- ```var person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};```

Other method:

- ```
 var person = new Object();
person.firstName = "John";
person.lastName = "Doe";
person.age = 50;
person.eyeColor = "blue";
```

Accessing Object Properties:

- objectName.propertyName
- objectName["propertyName"]

METHODS:

- A method is a function associated with an object, or, simply put, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. An example is:

```
objectName.methodname = function_name;

var myObj = {
  myMethod: function(params) {
    // ...do something
  }
};
```

ACCESSING OBJECT METHODS:

- objectName.methodName()
- name = person.fullName();

SCOPE:

- In JavaScript, scope is the set of variables, objects, and functions you have access to.
- Local variables have local scope: They can only be accessed within the function.

```
function myFunction() {
    var carName = "Volvo";
    // code here can use carName
}
```

- A variable declared outside a function, becomes GLOBAL.
- A global variable has global scope: All scripts and functions on a web page can access it.
- Do NOT create global variables unless you intend to.
- With JavaScript, the global scope is the complete JavaScript environment.
- In HTML, the global scope is the window object. All global variables belong to the window object.

```
var carName = " Volvo";
// code here can use carName
function myFunction() {
    // code here can use  carName
}
```

- Automatically Global. If you assign a value to a variable that has not been declared, it will automatically become a GLOBAL variable.


```
myFunction();
// code here can use carName
function myFunction() {
    carName = "Volvo";
}
```

PROTOTYPICAL INHERITANCE:

- When it comes to inheritance, JavaScript only has one construct: objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. null, by definition, has no prototype, and acts as the final link in this prototype chain.

- ```
var oldObject = {
  a: 2,
  m: function(b){
    return this.a + 1;
  }
};
 var newObject = Object.create(oldObject);
// newObject is an object that inherits from oldObject
```

Different ways to create objects and the resulting prototype chain

- Objects created with syntax constructs:

```
var o = {a: 1};

// The newly created object o has Object.prototype as its [[Prototype]]
// o has no own property named 'hasOwnProperty'
// hasOwnProperty is an own property of Object.prototype.
// So o inherits hasOwnProperty from Object.prototype
// Object.prototype has null as its prototype.
// o ---> Object.prototype ---> null

var a = ["yo", "whadup", "?"];

// Arrays inherit from Array.prototype
// (which has methods like indexOf, forEach, etc.)
// The prototype chain looks like:
// a ---> Array.prototype ---> Object.prototype ---> null

function f(){
  return 2;
}

// Functions inherit from Function.prototype
// (which has methods like call, bind, etc.)
// f ---> Function.prototype ---> Object.prototype ---> null
```

- With a constructor
  - A "constructor" in JavaScript is "just" a function that happens to be called with the new operator.

```
function Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype = {
  addVertex: function(v){
    this.vertices.push(v);
  }
};

var g = new Graph();
// g is an object with own properties 'vertices' and 'edges'.
// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.
```

- With Object.create
  - ECMAScript 5 introduced a new method: Object.create(). Calling this method creates a new object. The prototype of this object is the first argument of the function:

```
var a = {a: 1};
// a ---> Object.prototype ---> null

var b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (inherited)

var c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

var d = Object.create(null);
// d ---> null
console.log(d.hasOwnProperty);
// undefined, because d doesn't inherit from Object.prototype
```

- With the class keyword
  - ECMAScript 6 introduced a new set of keywords implementing classes. Although these constructs look like those familiar to developers of class-based languages, they are not the same. JavaScript remains prototype-based. The new keywords include class, constructor, static, extends, and super.

```
class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(sideLength) {
    super(sideLength, sideLength);
  }
  get area() {
    return this.height * this.width;
  }
  set sideLength(newLength) {
    this.height = newLength;
    this.width = newLength;
  }
}
var square = new Square(2);
```



# Document Objects assesses understanding of the JavaScript document object and the methods it provides for dynamically generating Web pages.
-

The HTML DOM Document Object

- The document object represents your web page.
- If you want to access any element in an HTML page, you always start with accessing the document object.

- document.getElementById(id)   Find an element by element id
- document.getElementsByTagName(name) Find elements by tag name
- document.getElementsByClassName(name) Find elements by class name

Changing HTML Elements

- element.innerHTML =  new html content Change the inner HTML of an element
- element.attribute = new value Change the attribute value of an HTML element
- element.setAttribute(attribute, value)  Change the attribute value of an HTML element
- element.style.property = new style  Change the style of an HTML element

Adding and Deleting Elements

- document.createElement(element) Create an HTML element
- document.removeChild(element) Remove an HTML element
- document.appendChild(element) Add an HTML element
- document.replaceChild(element)  Replace an HTML element
- document.write(text)  Write into the HTML output stream

Adding Events Handlers

- ```
document.getElementById(id).onclick = function(){code}
```

Finding HTML Objects

- The first HTML DOM Level 1 (1998), defined 11 HTML objects, object collections, and properties. These are still valid in HTML5.
- Later, in HTML DOM Level 3, more objects, collections, and properties were added.

```
document.anchors Returns all <a> elements that have a name attribute  1
document.applets Returns all <applet> elements (Deprecated in HTML5)  1
document.baseURI  Returns the absolute base URI of the document 3
document.body Returns the <body> element  1
document.cookie Returns the document's cookie 1
document.doctype  Returns the document's doctype  3
document.documentElement  Returns the <html> element  3
document.documentMode Returns the mode used by the browser  3
document.documentURI  Returns the URI of the document 3
document.domain Returns the domain name of the document server  1
document.domConfig  Obsolete. Returns the DOM configuration 3
document.embeds Returns all <embed> elements  3
document.forms  Returns all <form> elements 1
document.head Returns the <head> element  3
document.images Returns all <img> elements  1
document.implementation Returns the DOM implementation  3
document.inputEncoding  Returns the document's encoding (character set) 3
document.lastModified Returns the date and time the document was updated  3
document.links  Returns all <area> and <a> elements that have a href attribute  1
document.readyState Returns the (loading) status of the document  3
document.referrer Returns the URI of the referrer (the linking document)  1
document.scripts  Returns all <script> elements 3
document.strictErrorChecking  Returns if error checking is enforced 3
document.title  Returns the <title> element 1
document.URL  Returns the complete URL of the document
```

JavaScript - HTML DOM Methods

- HTML DOM methods are actions you can perform (on HTML Elements).

- HTML DOM properties are values (of HTML Elements) that you can set or change.

# Handling Events assesses knowledge of essential JavaScript event-handling operations including onChange, onClick, onLoad and other related events.
-

An HTML event can be something the browser does, or something a user does.

- Here are some examples of HTML events:
  - An HTML web page has finished loading
  - An HTML input field was changed
  - An HTML button was clicked

```
<button onclick="displayDate()">The time is?</button>
```

Here is a list of some common HTML events:

Event Description

- onchange  An HTML element has been changed
- onclick The user clicks an HTML element
- onmouseover The user moves the mouse over an HTML element
- onmouseout  The user moves the mouse away from an HTML element
- onkeydown The user pushes a keyboard key
- onload  The browser has finished loading the page


# Handling Functions determines knowledge of JavaScript function definition and calling, function arguments and functions as first class objects.
-

```
function name(parameter1, parameter2, parameter3) {
    code to be executed
}
```

- Function parameters are the names listed in the function definition.
- Function arguments are the real values received by the function when it is invoked.
- Inside the function, the arguments (the parameters) behave as local variables.

Function Invocation

The code inside the function will execute when "something" invokes (calls) the function:

- When an event occurs (when a user clicks a button)
- When it is invoked (called) from JavaScript code
- Automatically (self invoked)

- When JavaScript reaches a return statement, the function will stop executing.

```
var x = myFunction(4, 3);        // Function is called, return value will end up in x

function myFunction(a, b) {
    return a * b;                // Function returns the product of a and b
}
```

The Arguments Object

- JavaScript functions have a built-in object called the arguments object.
- The argument object contains an array of the arguments used when the function was called (invoked).

```
x = findMax(1, 123, 500, 115, 44, 88);

function findMax() {
    var i;
    var max = -Infinity;
    for (i = 0; i < arguments.length; i++) {
        if (arguments[i] > max) {
            max = arguments[i];
        }
    }
    return max;
}
```

Arguments are Passed by Value

- The parameters, in a function call, are the function's arguments.

Invoking a Function as a Method

```
var myObject = {
    firstName:"John",
    lastName: "Doe",
    fullName: function () {
        return this.firstName + " " + this.lastName;
    }
}
myObject.fullName();         // Will return "John Doe"
```

Invoking a Function with a Function Constructor

- If a function invocation is preceded with the new keyword, it is a constructor invocation.
- It looks like you create a new function, but since JavaScript functions are objects you actually create a new object:

```
// This is a function constructor:
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// This creates a new object
var x = new myFunction("John","Doe");
x.firstName;                             // Will return "John"
```

FIRST CLASS OBJECT:

-  In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object.


# HTML5 Form Elements tests knowledge of the HTML5 Form elements and validation of data input by the user.
-

JavaScript Form Validation

- HTML form validation can be done by JavaScript.
- If a form field (fname) is empty, this function alerts a message, and returns false, to prevent the form from being submitted:

```
function validateForm() {
    var x = document.forms["myForm"]["fname"].value;
    if (x == null || x == "") {
        alert("Name must be filled out");
        return false;
    }
}
```

HTML FORM:
```
<form name="myForm" action="demo_form.asp" onsubmit="return validateForm()" method="post">
Name: <input type="text" name="fname">
<input type="submit" value="Submit">
</form>
```

Automatic HTML Form Validation

- HTML form validation can be performed automatically by the browser:
- If a form field (fname) is empty, the required attribute prevents this form from being submitted:

```
<form action="demo_form.asp" method="post">
  <input type="text" name="fname" required>
  <input type="submit" value="Submit">
</form>
```

Data Validation

- Data validation is the process of ensuring that user input is clean, correct, and useful.

Typical validation tasks are:

- has the user filled in all required fields?
- has the user entered a valid date?
- has the user entered text in a numeric field?
- Most often, the purpose of data validation is to ensure correct user input.

- Validation can be defined by many different methods, and deployed in many different ways.
- Server side validation is performed by a web server, after input has been sent to the server.
- Client side validation is performed by a web browser, before input is sent to a web server.

HTML Constraint Validation

- HTML5 introduced a new HTML validation concept called constraint validation.

HTML constraint validation is based on:

- Constraint validation HTML Input Attributes
- Constraint validation CSS Pseudo Selectors
- Constraint validation DOM Properties and Methods
- Constraint Validation HTML Input Attributes

Attribute Description

- disabled  Specifies that the input element should be disabled
- max Specifies the maximum value of an input element
- min Specifies the minimum value of an input element
- pattern Specifies the value pattern of an input element
- required  Specifies that the input field requires an element
- type  Specifies the type of an input element
- validity  Contains boolean properties related to the validity of an input element.
- validationMessage Contains the message a browser will display when the validity is false.
- willValidate  Indicates if an input element will be validated.

Constraint Validation CSS Pseudo Selectors

Selector  Description

- :disabled Selects input elements with the "disabled" attribute specified
- :invalid  Selects input elements with invalid values
- :optional Selects input elements with no "required" attribute specified
- :required Selects input elements with the "required" attribute specified
- :valid  Selects input elements with valid values

Validity Properties

The validity property of an input element contains a number of properties related to the validity of data:

Property  Description

- customError Set to true, if a custom validity message is set.
- patternMismatch Set to true, if an element's value does not match its pattern attribute.
- rangeOverflow Set to true, if an element's value is greater than its max attribute.
- rangeUnderflow  Set to true, if an element's value is less than its min attribute.
- stepMismatch  Set to true, if an element's value is invalid per its step attribute.
- tooLong Set to true, if an element's value exceeds its maxLength attribute.
- typeMismatch  Set to true, if an element's value is invalid per its type attribute.
- valueMissing  Set to true, if an element (with a required attribute) has no value.
- valid Set to true, if an element's value is valid.

```
<input id="id1" type="number" max="100">
<button onclick="myFunction()">OK</button>

<p id="demo"></p>

<script>
function myFunction() {
    var txt = "";
    if (document.getElementById("id1").validity.rangeOverflow) {
       txt = "Value too large";
    }
    document.getElementById("demo").innerHTML = txt;
}
</script>
```


# HTML5 DOM measures knowledge of the Document Object Model interface, and manipulating the DOM using JavaScript.
-

The HTML DOM Document Object

- The document object represents your web page.
- If you want to access any element in an HTML page, you always start with accessing the document object.

- document.getElementById(id)   Find an element by element id
- document.getElementsByTagName(name) Find elements by tag name
- document.getElementsByClassName(name) Find elements by class name

Changing HTML Elements

- element.innerHTML =  new html content Change the inner HTML of an element
- element.attribute = new value Change the attribute value of an HTML element
- element.setAttribute(attribute, value)  Change the attribute value of an HTML element
- element.style.property = new style  Change the style of an HTML element

Adding and Deleting Elements

- document.createElement(element) Create an HTML element
- document.removeChild(element) Remove an HTML element
- document.appendChild(element) Add an HTML element
- document.replaceChild(element)  Replace an HTML element
- document.write(text)  Write into the HTML output stream

Adding Events Handlers

- ```
document.getElementById(id).onclick = function(){code}
```

Finding HTML Objects

- The first HTML DOM Level 1 (1998), defined 11 HTML objects, object collections, and properties. These are still valid in HTML5.
- Later, in HTML DOM Level 3, more objects, collections, and properties were added.

```
document.anchors Returns all <a> elements that have a name attribute  1
document.applets Returns all <applet> elements (Deprecated in HTML5)  1
document.baseURI  Returns the absolute base URI of the document 3
document.body Returns the <body> element  1
document.cookie Returns the document's cookie 1
document.doctype  Returns the document's doctype  3
document.documentElement  Returns the <html> element  3
document.documentMode Returns the mode used by the browser  3
document.documentURI  Returns the URI of the document 3
document.domain Returns the domain name of the document server  1
document.domConfig  Obsolete. Returns the DOM configuration 3
document.embeds Returns all <embed> elements  3
document.forms  Returns all <form> elements 1
document.head Returns the <head> element  3
document.images Returns all <img> elements  1
document.implementation Returns the DOM implementation  3
document.inputEncoding  Returns the document's encoding (character set) 3
document.lastModified Returns the date and time the document was updated  3
document.links  Returns all <area> and <a> elements that have a href attribute  1
document.readyState Returns the (loading) status of the document  3
document.referrer Returns the URI of the referrer (the linking document)  1
document.scripts  Returns all <script> elements 3
document.strictErrorChecking  Returns if error checking is enforced 3
document.title  Returns the <title> element 1
document.URL  Returns the complete URL of the document
```

JavaScript - HTML DOM Methods

- HTML DOM methods are actions you can perform (on HTML Elements).

- HTML DOM properties are values (of HTML Elements) that you can set or change.


# HTML5 Document Security and Design Concerns tests knowledge of the Document security features of HTML5, including the use of the sandbox attribute, and general web site design concerns.
-

CROSS SITE SCRIPTING

- A cross-site scripting (XSS) hole is when an attacker can inject scripts into a page sent by your server. Browsers treat these injected scripts like any other script in the page.

Password fields in user-submitted HTML

- Web sites should not allow users to put up forms with < input type="password" >. Password managers may fill in the password, thinking the form is a legitimate part of the site.

Cross-site request forgery (CSRF)

- A Cross-site request forgery hole is when a malicious site can cause a visitor's browser to make a request to your server that causes a change on the server. The server thinks that because the request comes with the user's cookies, the user wanted to submit that form.

Sandboxed frames

- Use the sandbox attribute of an iframe for untrusted content.

# HTML5 Images and External Documents determines knowledge of using images and other external content within an HTML5 document, and using external CSS3 and JavaScript files.
-

Images

```
<img src="smiley.gif" alt="Smiley face">
```

Link

```
<a href="http://www.w3schools.com/html/">Visit our HTML tutorial</a>
```

CSS

```
<head>
<link rel="stylesheet" type="text/css" href="mystyle.css">
</head>
```

JS

```
<script src="myscripts.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
```

LOADING EXTERNAL HTML DOC:

```
<object data="html/stuff_to_include.html">
    Your browser doesn’t support the object tag.
</object>
```


# HTML5 Syntax and Semantics tests knowledge of the DOCTYPE element, character encoding and use of HTML5 syntax and semantics to build valid HTML5 documents.
-

The <!DOCTYPE> declaration is not an HTML tag; it is an instruction to the web browser about what version of HTML the page is written in.

Tip: Always add the <!DOCTYPE> declaration to your HTML documents, so that the browser knows what type of document to expect.

```
<!DOCTYPE html>
```

CHARACTER ENCODING

- To display an HTML page correctly, a web browser must know which character set (character encoding) to use.
- alphanumeric characters that could be used on the internet: numbers (0-9), English letters (A-Z), and some special characters like ! $ + - ( ) @ < > .
- ANSI (Windows-1252) was the original Windows character set, with support for 256 different character codes.
- ISO-8859-1 was the default character set for HTML 4. This character set also supported 256 different character codes.
- Because ANSI and ISO-8859-1 were so limited, the default character encoding was changed to UTF-8 in HTML5.
- UTF-8 (Unicode) covers almost all of the characters and symbols in the world.

```
<head>
  <meta charset="utf-8">
</head>
```

SEMANTIC HTML

Semantic HTML is the use of HTML markup to reinforce the semantics, or meaning, of the information in webpages and web applications rather than merely to define its presentation or look.

- As an example, recent HTML standards discourage use of the tag < i > (italic, a typeface) in preference of more accurate tags such as < em > (emphasis); the CSS stylesheet should then specify whether emphasis is denoted by an italic font, a bold font, underlining, slower or louder audible speech etc. This is because italics are used for purposes other than emphasis, such as citing a source; for this, HTML 4 provides the tag < cite >.


# HTML5 Tables, Lists and Links tests knowledge of the use of tables, ordered and unordered lists, Links elements within HTML5.
-

TABLE


- An HTML table is defined with the < table > tag.
- Each table row is defined with the < tr > tag. A table header is defined with the < th > tag. By default, table headings are bold and centered. A table data/cell is defined with the < td > tag.

```
<table style="width:100%">
  <tr>
    <th>Firstname</th>
    <th>Lastname</th>
    <th>Age</th>
  </tr>
  <tr>
    <td>Jill</td>
    <td>Smith</td>
    <td>50</td>
  </tr>
  <tr>
    <td>Eve</td>
    <td>Jackson</td>
    <td>94</td>
  </tr>
</table>
```

LISTS

Unordered List

- An unordered list starts with the < ul > tag. Each list item starts with the < li > tag.
- The list items will be marked with bullets (small black circles) by default:

```
<ul style="list-style-type:disc">
  <li>Coffee</li>
  <li>Tea</li>
  <li>Milk</li>
</ul>
```
List Style Type

- The CSS list-style-type property is used to define the style of the list item marker:

```
Value Description
disc  Sets the list item marker to a bullet (default)
circle  Sets the list item marker to a circle
square  Sets the list item marker to a square
none  The list items will not be marked
```

Ordered HTML List

- An ordered list starts with the < ol > tag. Each list item starts with the < li > tag.

Ordered HTML List - The Type Attribute

- The type attribute of the < ol > tag, defines the type of the list item marker:

```

Type  Description
type="1"  The list items will be numbered with numbers (default)
type="A"  The list items will be numbered with uppercase letters
type="a"  The list items will be numbered with lowercase letters
type="I"  The list items will be numbered with uppercase roman numbers
type="i"  The list items will be numbered with lowercase roman numbers
```

HTML Description Lists

- A description list is a list of terms, with a description of each term.
- The < dl > tag defines the description list, the < dt > tag defines the term (name), and the < dd > tag describes each term:

```
<dl>
  <dt>Coffee</dt>
  <dd>- black hot drink</dd>
  <dt>Milk</dt>
  <dd>- white cold drink</dd>
</dl>
```

produces:

```
A Description List

Coffee
- black hot drink
Milk
- white cold drink
```

Nested HTML Lists

```
<ul>
  <li>Coffee</li>
  <li>Tea
    <ul>
      <li>Black tea</li>
      <li>Green tea</li>
    </ul>
  </li>
  <li>Milk</li>
</ul>
```

LINKS:

Abosolute URL:

```
<a href="http://www.w3schools.com/html/">Visit our HTML tutorial</a>
```

Relative URL / Local:

```
<a href="html_images.asp">HTML Images</a>
```

TML Links - The target Attribute

- The target attribute specifies where to open the linked document.

```
<a href="http://www.w3schools.com/" target="_blank">Visit W3Schools!</a>
```

HTML Links - Create a Bookmark

- HTML bookmarks are used to allow readers to jump to specific parts of a Web page.

First, create a bookmark with the id attribute:

```
<h2 id="tips">Useful Tips Section</h2>
```

Then, add a link to the bookmark ("Useful Tips Section"), from within the same page:

```
<a href="#tips">Visit the Useful Tips Section</a>
```




# HTML5 Validation Issues and Browser Support determines knowledge of how to validate HTML5 documents, and the checking for HTML5 features in the browser.
-

HTML Validator

- Validates the HTML string/file for well-formedness and compliance with w3c standards. It tries to make use of the doctype declaration to evaluate the document structrue but will resort to best practice if unmatched. The validator will report on missing or invalid attributes, unknown tags, unclosed tags and more.

```
https://validator.w3.org/
```

Which features will Work in Which Browsers?

```
http://caniuse.com/
```



# Using JavaScript tests understanding of the core features of JavaScript used in conjunction with HTML5, including basic syntax and operators.
-



# AngularJS Architecture tests knowledge of AngularJS services, how to hook AngularJS to an HTML document and to organize an AngularJS project (module definition, module dependencies, use dependency injection to consume services).
-

ANGULAR SERVICES:

- Angular services are substitutable objects that are wired together using dependency injection (DI). You can use services to organize and share code across your app.
- Angular services are: Lazily instantiated – Angular only instantiates a service when an application component depends on it.
- Angular offers several useful services (like $http), but for most applications you'll also want to create your own.

Using a Service

- To use an Angular service, you add it as a dependency for the component (controller, service, filter or directive) that depends on the service. Angular's dependency injection subsystem takes care of the rest.

```
angular.
module('myServiceModule', []).
 controller('MyController', ['$scope', 'notify', function($scope, notify) {
   $scope.callNotify = function(msg) {
     notify(msg);
   };
 }]).
factory('notify', ['$window', function(win) {
   var msgs = [];
   return function(msg) {
     msgs.push(msg);
     if (msgs.length === 3) {
       win.alert(msgs.join('\n'));
       msgs = [];
     }
   };
 }]);

```

Creating Services

- Application developers are free to define their own services by registering the service's name and service factory function, with an Angular module.
- The service factory function generates the single object or function that represents the service to the rest of the application. The object or function returned by the service is injected into any component (controller, service, filter or directive) that specifies a dependency on the service.

Registering Services

Angular provides us with three ways to create and register our own service.

- 1) Factory
  -  When you’re using a Factory you create an object, add properties to it, then return that same object. When you pass this service into your controller, those properties on the object will now be available in that controller through your factory.
    ![code](https://cdn-images-1.medium.com/max/800/0*C8zf8H1AlRVxOpKq.png)

    ```
    angular.module("services", [])
    .factory("myFactory", [function () {
        // Logic goes here.
    }]);
    ```
    ```
    .factory("myFactory", ["dependency", function (dependency) {
    // ...
    ```

```
var app = angular.module("myApp", []);

app.controller("myCtrl", ['$scope', 'userService', function($scope, userService) {
    $scope.firstName = "John";
    $scope.lastName = "Doe";

    $scope.doIt = function(){
      userService.firstFunction();
    }
}]);

app.factory('userService', [function(){

var blah = {};
  blah.firstFunction = function () {
    $("#demo").html("This text is userService through a factory and connected to the dom with $scope!");
    // alert('userService through factory!');
  };

return blah;
}]);
```

- 2) Service
  - When you’re using Service, it’s instantiated with the ‘new’ keyword. Because of that, you’ll add properties to ‘this’ and the service will return ‘this’. When you pass the service into your controller, those properties on ‘this’ will now be available on that controller through your service.
  -
  ![pic](https://cdn-images-1.medium.com/max/800/0*IwVP-hgA-ivxlP3P.png)
- 3) Provider
  - Providers are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.
![pic](https://cdn-images-1.medium.com/max/800/0*MOu_5Sbnm9ps5N6i.png)


```
var myModule = angular.module('myModule', []);
myModule.factory('serviceId', function() {
  var shinyNewServiceInstance;
  // factory function body that constructs shinyNewServiceInstance
  return shinyNewServiceInstance;
});
```

Hook Angular to HTML:

```
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.7/angular.min.js"></script>
```

```
<body ng-app="">
```

MODULE.

- A module is a collection of services, directives, controllers, filters, and configuration information. angular.module is used to configure the $injector.
- However it's more likely that you'll just use ngApp or angular.bootstrap to simplify this process for you.
- The angular.module is a global place for creating, registering and retrieving Angular modules. All modules (angular core or 3rd party) that should be available to an application must be registered using this mechanism.
- An AngularJS module defines an application.
- The module is a container for the different parts of an application.
- The module is a container for the application controllers.
- Controllers always belong to a module.
- Global functions should be avoided in JavaScript. They can easily be overwritten or destroyed by other scripts.
- AngularJS modules reduces this problem, by keeping all functions local to the module.
-  In its simplest form the module consists of a collection of two kinds of blocks:
  - Configuration blocks - get executed during the provider registrations and configuration phase. Only providers and constants can be injected into configuration blocks. This is to prevent accidental instantiation of services before they have been fully configured.
  - Run blocks - get executed after the injector is created and are used to kickstart the application. Only instances and constants can be injected into run blocks. This is to prevent further system configuration during application run time.


```
angular.module('myModule', []).
config(function(injectables) { // provider-injector
  // This is an example of config block.
  // You can have as many of these as you want.
  // You can only inject Providers (not instances)
  // into config blocks.
}).
run(function(injectables) { // instance-injector
  // This is an example of a run block.
  // You can have as many of these as you want.
  // You can only inject instances (not Providers)
  // into run blocks
});
```

Configuration Blocks

- There are some convenience methods on the module which are equivalent to the config block. For example:

```
angular.module('myModule', []).
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// is same as


angular.module('myModule', []).
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { return 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });
```

```
angular.module(name, [requires], [configFn]);
```

```
Param Type  Details
name  string
The name of the module to create or retrieve.

requires
(optional)
!Array.<string>=
If specified then new module is being created. If unspecified then the module is being retrieved for further configuration.

configFn
(optional)
Function=
Optional configuration function for the module. Same as Module#config().
```

Adding a Controller

- Add a controller to your application, and refer to the controller with the ng-controller directive:

```
<script>

var app = angular.module("myApp", []);

app.controller("myCtrl", function($scope) {
    $scope.firstName = "John";
    $scope.lastName = "Doe";
});

</script>
```

Adding a Directive

- AngularJS has a set of built-in directives which you can use to add functionality to your application.
- Custom directives are used in AngularJS to extend the functionality of HTML. Custom directives are defined using "directive" function. A custom directive simply replaces the element for which it is activated.
- In addition you can use the module to add your own directives to your applications:

```
app.directive("w3TestDirective", function() {
    return {
        template : "I was made in a directive constructor!"
    };
```
```
IN JS:
  app.directive('student', function() {
   //define the directive object
   var directive = {};

   //restrict = E, signifies that directive is Element directive
   directive.restrict = 'E';

   //template replaces the complete element with its text.
   directive.template = "Student: <b>{{student.name}}</b> , Roll No:  <b>{{student.rollno}}</b>";

   //scope is used to distinguish each student element based on criteria.
   directive.scope = {
      student : "=name"
   }
  return directive;
});

IN CONTROLLER:
   $scope.Mahesh = {};
   $scope.Mahesh.name = "Mahesh Parashar";
   $scope.Mahesh.rollno  = 1;

   $scope.Piyush = {};
   $scope.Piyush.name = "Piyush Parashar";
   $scope.Piyush.rollno  = 2;

IN HTML:
   <student name = "Mahesh"></student><br/>
  <student name = "Piyush"></student>
```

Modules and Controllers in Files

- It is common in AngularJS applications to put the module and the controllers in JavaScript files.

```
<script src="myApp.js"></script>
<script src="myCtrl.js"></script>
```

MODULE DEPENDENCIES:

- Modules can list other modules as their dependencies. Depending on a module implies that the required module needs to be loaded before the requiring module is loaded. In other words the configuration blocks of the required modules execute before the configuration blocks of the requiring module. The same is true for the run blocks. Each module can only be loaded once, even if multiple other modules require it.

DEPENDENCY INJECTION:

- Dependency Injection (DI) is a software design pattern that deals with how components get hold of their dependencies.
- Dependency Injection is a software design pattern in which an object is given its dependencies, rather than the object creating them itself.
- The Angular injector subsystem is in charge of creating components, resolving their dependencies, and providing them to other components as requested.
- Angular leverages dependency injection all across the framework. It works with functions defined for controller, directive, service, factory, etc.

```
var app = angular.module("DemoApp", []);
// Controller is injected with $scope and $http as dependencies
app.controller("DemoController", function ($scope, $http) {
    $http.get('https://api.github.com/users/angular/repos')
        .success(function (repos) {
        $scope.repos = repos
    });
```

- In the above example, the controller DemoController is injected with two dependencies: $scope and $http. The controller doesn’t know/care how these objects are created.


# AngularJS Standard Services tests knowledge of the services included with AngularJS for URL management and back-end communication, such as $resource, $http, $location and $route.
-

$resource

- A factory which creates a resource object that lets you interact with RESTful server-side data sources.
- The returned resource object has action methods which provide high-level behaviors without the need to interact with the low level $http service.
- Requires the ngResource module to be installed.

```
app.config(['$resourceProvider', function($resourceProvider) {
  // Don't strip trailing slashes from calculated URLs
  $resourceProvider.defaults.stripTrailingSlashes = false;
}]);
```

```
$resource(url, [paramDefaults], [actions], options);
```

URL:
```
$resource('http://example.com/resource.json')
```

paramDefaults
(optional)

- Default values for url parameters.
- Given a template /path/:verb and parameter {verb:'greet', salutation:'Hello'} results in URL /path/greet?salutation=Hello.

actions
(optional)

- Hash with declaration of custom actions that will be available in addition to the default set of resource actions (see below). If a custom action has the same key as a default action (e.g. save), then the default action will be overwritten, and not extended.
- The declaration should be created in the format of $http.config:

```
{action1: {method:?, params:?, isArray:?, headers:?, ...},
 action2: {method:?, params:?, isArray:?, headers:?, ...},
 ...}
```

Options

- Hash with custom settings that should extend the default $resourceProvider behavior. The supported options are:
  - stripTrailingSlashes – {boolean} – If true then the trailing slashes from any calculated URL will be stripped. (Defaults to true.)
  - cancellable – {boolean} – If true, the request made by a "non-instance" call will be cancelled (if not already completed) by calling $cancelRequest() on the call's return value. This can be overwritten per action. (Defaults to false.)

Returns

- A resource "class" object with methods for the default set of resource actions optionally extended with custom actions. The default set contains these actions:

```
{ 'get':    {method:'GET'},
  'save':   {method:'POST'},
  'query':  {method:'GET', isArray:true},
  'remove': {method:'DELETE'},
  'delete': {method:'DELETE'} };
```
```
var User = $resource('/user/:userId', {userId:'@id'});
var user = User.get({userId:123}, function() {
  user.abc = true;
  user.$save();
});
```

$http

- The $http service is a core Angular service that facilitates communication with the remote HTTP servers via the browser's XMLHttpRequest object or via JSONP.
- The $http service is a function which takes a single argument — a configuration object — that is used to generate an HTTP request and returns a promise.

```
// Simple GET request example:
$http({
  method: 'GET',
  url: '/someUrl'
}).then(function successCallback(response) {
    // this callback will be called asynchronously
    // when the response is available
  }, function errorCallback(response) {
    // called asynchronously if an error occurs
    // or server returns response with an error status.
  });
```

```
<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
    $http.get("welcome.htm")
    .then(function(response) {
        $scope.myWelcome = response.data;
    });
});
</script>
```

Shortcut methods

- Shortcut methods are also available. All shortcut methods require passing in the URL, and request data must be passed in for POST/PUT requests. An optional config can be passed as the last argument.

```
$http.get('/someUrl', config).then(successCallback, errorCallback);
$http.post('/someUrl', data, config).then(successCallback, errorCallback);
```

Complete list of shortcut methods:

- $http.get
- $http.head
- $http.post
- $http.put
- $http.delete
- $http.jsonp
- $http.patch

 ```
 $http(config);
 ```

 Methods

```
 get(url, [config]);
 delete(url, [config]);
 head(url, [config]);
 post(url, data, [config]);
 put(url, data, [config]);

 patch(url, data, [config]);

```

$location

- The $location service parses the URL in the browser address bar (based on the window.location) and makes the URL available to your application.
- Changes to the URL in the address bar are reflected into $location service and changes to $location are reflected into the browser address bar.

Methods

- absUrl();

```
var absUrl = $location.absUrl();
```

- url([url]);

```
var url = $location.url();
```

- here are two configuration modes that you can use: the Hashbang mode and the HTML5 mode.

```
$locationProvider.html5Mode(true).hashPrefix('*');
```

$route

- $route is used for deep-linking URLs to controllers and views (HTML partials). It watches $location.url() and tries to map the path to an existing route definition.
- Requires the ngRoute module to be installed.
- AngularJS routes enable you to create different URLs for different content in your application. Having different URLs for different content enables the user to bookmark URLs to specific content, and send those URLs to friends etc.
- AngularJS routes enables you to show different content depending on what route is chosen. A route is specified in the URL after the # sign. Thus, the following URL's all point to the same AngularJS application, but each point to different routes:

```
    http://myangularjsapp.com/index.html#books
    http://myangularjsapp.com/index.html#albums
    http://myangularjsapp.com/index.html#games
    http://myangularjsapp.com/index.html#apps
```

- When the browser loads these links, the same AngularJS application will be loaded (located at http://myangularjsapp.com/index.html), but AngularJS will look at the route (the part of the URL after the #) and decide what HTML template to show.

```
<script>
    var module = angular.module("sampleApp", ['ngRoute']);

    module.config(['$routeProvider',
        function($routeProvider) {
            $routeProvider.
                when('/route1', {
                    templateUrl: 'angular-route-template-1.jsp',
                    controller: 'RouteController'
                }).
                when('/route2', {
                    templateUrl: 'angular-route-template-2.jsp',
                    controller: 'RouteController'
                }).
                otherwise({
                    redirectTo: '/'
                });
        }]);

    module.controller("RouteController", function($scope) {

    })
</script>
```

Including the AngularJS Route Module

- The first thing to notice in the example application above is the extra JavaScript included inside the head section:

```
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.5/angular-route.min.js"></script>
```
Declaring a Dependency on the AngularJS Route Module

- The second thing to notice is that the applications's AngularJS module (called sampleApp) declares a dependency on the AngularJS route module:

```
var module = angular.module("sampleApp", ['ngRoute']);
```

The ngView Directive

- The third thing to notice in the example above is the use of the ngView directive:

```
<div ng-view></div>
```

- Inside the div with the ngView directive (can also be written ng-view) the HTML template specific to the given route will be displayed.

Links to Routes

- The final thing to notice in this example is the two links in the HTML page:

```
<a href="#/route1">Route 1</a><br/>
<a href="#/route2">Route 2</a><br/>
```


METHODS

- reload();
  - Causes $route service to reload the current route even if $location hasn't changed.

updateParams(newParams);

- Causes $route service to update the current URL, replacing current route parameters with those specified in newParams. Provided property names that match the route's path segment definitions will be interpolated into the location's path, while remaining properties will be treated as query params.

Parameters

Param Type  Details

```
newParams !Object<string, string>
mapping of URL parameter names to values
```

EVENTS

- $routeChangeStart
  - Broadcasted before a route change. At this point the route services starts resolving all of the dependencies needed for the route change to occur.

# Controllers and Scopes assesses understanding of the scope element (the $rootScope element, $scope methods, relation between scopes) and the controller element (declaration of controllers, binding controllers to scopes) in AngularJS.
-

CONTROLLERS

- AngularJS controllers control the data of AngularJS applications.
- AngularJS controllers are regular JavaScript Objects.

```
<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
    $scope.firstName = "John";
    $scope.lastName = "Doe";
});
</script>
```

Controller Methods

- A controller can also have methods (variables as functions):

```
Full Name: {{fullName()}}

$scope.fullName = function() {
        return $scope.firstName + " " + $scope.lastName;
    };
```

Scope

- The scope is the binding part between the HTML (view) and the JavaScript (controller).

$rootScope

- Every application has a single root scope. All other scopes are descendant scopes of the root scope.
- All applications have a $rootScope which is the scope created on the HTML element that contains the ng-app directive.
- The rootScope is available in the entire application.
- Attaching variables to the rootscope means not having to use ng-controller for a specific controller's scope. This scope is global.

```
app.run(function($rootScope) {
    $rootScope.color = 'blue';
});
```

- If a variable has the same name in both the current scope and in the rootScope, the application use the one in the current scope.

angular.element


- Wraps a raw DOM element or HTML string as a jQuery element.

Declarations of Controller:

```
<div ng-controller="GreetingController">
  {{ greeting }}
</div>
```

```
var myApp = angular.module('myApp',[]);

myApp.controller('GreetingController', ['$scope', function($scope) {
  $scope.greeting = 'Hola!';
}]);
```



# Creating Custom Directives and Filters determines knowledge of common options in AngularJS to define custom directives and filters and how to use them. Evaluates knowledge of concepts about custom directives: transclusion, definition and binding of parameters in AngularJS.
-

CUSTOM DIRECTIVES

- Custom directives are used in AngularJS to extend the functionality of HTML.

Define custom html tags.

```
<student name = "Mahesh"></student><br/>
<student name = "Piyush"></student>
```

Define custom directive to handle above custom html tags.

```
mainApp.directive('student', function() {
   //define the directive object
   var directive = {};

   //restrict = E, signifies that directive is Element directive
   directive.restrict = 'E';

   //template replaces the complete element with its text.
   directive.template = "Student: <b>{{student.name}}</b> , Roll No: <b>{{student.rollno}}</b>";

   //scope is used to distinguish each student element based on criteria.
   directive.scope = {
      student : "=name"
   }
   return directive;
```

Define controller to update the scope for directive.

Here we are using name attribute's value as scope's child.

```
mainApp.controller('StudentController', function($scope) {
   $scope.Mahesh = {};
   $scope.Mahesh.name = "Mahesh Parashar";
   $scope.Mahesh.rollno  = 1;

   $scope.Piyush = {};
   $scope.Piyush.name = "Piyush Parashar";
   $scope.Piyush.rollno  = 2;
});
```

```
<div ng-app = "mainApp" ng-controller = "StudentController">
         <student name = "Mahesh"></student><br/>
         <student name = "Piyush"></student>
      </div>
```


CUSTOM FILTER

```
app.filter('startsWithA', function () {
  return function (items) {
    var filtered = [];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (/a/i.test(item.name.substring(0, 1))) {
        filtered.push(item);
      }
    }
    return filtered;
  };
});
```

```
<ul>
  <li ng-repeat="friend in person.friends | startsWithA">
    {{ friend }}
  </li>
</ul>
```

TRANSCLUSION

- The basic use case for transclusion is straightforward: You want to include some content from one template to another.
- What we would like to do is what we would naturally do if < my-directive > was any regular HTML tag: Just nest the content as HTML inside it. This is what transclusion is for.
- If we enable it by configuring transclude: true on the myCard directive, what happens is that Angular grabs the original contents of the < my-directive > element and makes them available for us to attach somewhere in our template.

```
<div my-directive>
    <button>some button</button>
    <a href="#">and a link</a>
</div>
```

will result in this render:

```
<div class="something"> This is my directive content</div>
```
Notice that the content of your original element < div my-directive > will be lost (or better said, replaced). So, say good-bye to these buddies:

```
<button>some button</button>
<a href="#">and a link</a>
```

- So, what if you want to keep your < button >... and < a href >... in the DOM? You'll need something called transclusion.

```
app.directive('myDirective', function(){
    return{
        transclude: true,
        template: '<div class="something" ng-transclude> This is my directive content</div>'
    }
});
```

This would render:

```
<div class="something"> This is my directive content
    <button>some button</button>
    <a href="#">and a link</a>
</div>.
```




# Forms Management evaluates proficiency in AngularJS directives used to manage forms and input elements: how to check the valid state of the form and the input elements, and how to expand the behavior of the input elements.
-

Simple form

- The key directive in understanding two-way data-binding is ngModel.
- The ngModel directive provides the two-way data-binding by synchronizing the model to the view, as well as view to the model.

```
  <form novalidate class="simple-form">
    Name: <input type="text" ng-model="user.name" /><br />
    E-mail: <input type="email" ng-model="user.email" /><br />
    Gender: <input type="radio" ng-model="user.gender" value="male" />male
    <input type="radio" ng-model="user.gender" value="female" />female<br />
    <input type="button" ng-click="reset()" value="Reset" />
    <input type="submit" ng-click="update(user)" value="Save" />
  </form>
  <pre>user = {{user | json}}</pre>
  <pre>master = {{master | json}}</pre>
</div>

<script>
  angular.module('formExample', [])
    .controller('ExampleController', ['$scope', function($scope) {
      $scope.master = {};

      $scope.update = function(user) {
        $scope.master = angular.copy(user);
      };

      $scope.reset = function() {
        $scope.user = angular.copy($scope.master);
      };

      $scope.reset();
    }]);
</script>
```

- Note that novalidate is used to disable browser's native form validation.
- The value of ngModel won't be set unless it passes validation for the input field. For example: inputs of type email must have a value in the form of user@domain.

Binding to form and control state

- A form is an instance of FormController. The form instance can optionally be published into the scope using the name attribute.
- Similarly, an input control that has the ngModel directive holds an instance of NgModelController. Such a control instance can be published as a property of the form instance using the name attribute on the input control. The name attribute specifies the name of the property on the form instance.
- This implies that the internal state of both the form and the control is available for binding in the view using the standard binding primitives.

Custom Validation

- With a custom directive, you can add your own validation functions to the $validators object on the ngModelController.
- Each function in the $validators object receives the modelValue and the viewValue as parameters. Angular will then call $setValidity internally with the function's return value (true: valid, false: invalid).
- An 'integer' directive that validates whether the input is a valid integer. For example, 1.23 is an invalid value, since it contains a fraction.
- A username directive that asynchronously checks if a user-entered value is already taken.

```
<form name="form" class="css-form" novalidate>
  <div>
    Size (integer 0 - 10):
    <input type="number" ng-model="size" name="size"
           min="0" max="10" integer />{{size}}<br />
    <span ng-show="form.size.$error.integer">The value is not a valid integer!</span>
    <span ng-show="form.size.$error.min || form.size.$error.max">
      The value must be in range 0 to 10!</span>
  </div>
  <div>
    Username:
    <input type="text" ng-model="name" name="name" username />{{name}}<br />
    <span ng-show="form.name.$pending.username">Checking if this name is available...</span>
    <span ng-show="form.name.$error.username">This username is already taken!</span>
  </div>
</form>
```

Checkbox

- A checkbox has the value true or false. Apply the ng-model directive to a checkbox, and use its value in your application.

```
 <form>
    Check to show a header:
    <input type="checkbox" ng-model="myVar">
</form>

<h1 ng-show="myVar">My Header</h1>
```

Radiobuttons

- Bind radio buttons to your application with the ng-model directive.
- Radio buttons with the same ng-model can have different values, but only the selected one will be used.


```
 <form>
Pick a topic:
<input type="radio" ng-model="myVar" value="dogs">Dogs
<input type="radio" ng-model="myVar" value="tuts">Tutorials
<input type="radio" ng-model="myVar" value="cars">Cars
</form>
```

Selectbox

- Bind select boxes to your application with the ng-model directive.
- The property defined in the ng-model attribute will have the value of the selected option in the selectbox.

```
<form>
Select a topic:
<select ng-model="myVar">
    <option value="">
    <option value="dogs">Dogs
    <option value="tuts">Tutorials
    <option value="cars">Cars
</select>
</form>
```

INPUT

```
<input
  ng-model="string"
  [name="string"]
  [required="string"]
  [ng-required="boolean"]
  [ng-minlength="number"]
  [ng-maxlength="number"]
  [ng-pattern="string"]
  [ng-change="string"]
  [ng-trim="boolean"]>
...
</input>
```

Arguments


- ngModel string
  - Assignable angular expression to data-bind to.
- name (optional) string
  - Property name of the form under which the control is published.
- required (optional) string
  - Sets required validation error key if the value is not entered.
- ngRequired (optional) boolean
  - Sets required attribute if set to true
- ngMinlength (optional) number
  - Sets minlength validation error key if the value is shorter than minlength.
- ngMaxlength (optional) number
  - Sets maxlength validation error key if the value is longer than maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any length.
- ngPattern (optional) string
  - Sets pattern validation error key if the ngModel $viewValue value does not match a RegExp found by evaluating the Angular expression given in the attribute value. If the expression evaluates to a RegExp object, then this is used directly. If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it in ^ and $ characters. For instance, "abc" will be converted to new RegExp('^abc$').
Note: Avoid using the g flag on the RegExp, as it will cause each successive search to start at the index of the last search's match, thus not taking the whole input value into account.
- ngChange (optional) string
  - Angular expression to be executed when input changes due to user interaction with the input element.
- ngTrim (optional) boolean
  - If set to false Angular will not automatically trim the input. This parameter is ignored for input[type=password] controls, which will never trim the input.

```
<script>
   angular.module('inputExample', [])
     .controller('ExampleController', ['$scope', function($scope) {
       $scope.user = {name: 'guest', last: 'visitor'};
     }]);
</script>
<div ng-controller="ExampleController">
  <form name="myForm">
    <label>
       User name:
       <input type="text" name="userName" ng-model="user.name" required>
    </label>
    <div role="alert">
      <span class="error" ng-show="myForm.userName.$error.required">
       Required!</span>
    </div>
    <label>
       Last name:
       <input type="text" name="lastName" ng-model="user.last"
       ng-minlength="3" ng-maxlength="10">
    </label>
    <div role="alert">
      <span class="error" ng-show="myForm.lastName.$error.minlength">
        Too short!</span>
      <span class="error" ng-show="myForm.lastName.$error.maxlength">
        Too long!</span>
    </div>
  </form>
  <hr>
  <tt>user = {{user}}</tt><br/>
  <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br/>
  <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br/>
  <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br/>
  <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br/>
  <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
  <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
  <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br/>
  <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br/>
</div>


User name:  guest
Last name:  visitor
user = {"name":"guest","last":"visitor"}
myForm.userName.$valid = true
myForm.userName.$error = {}
myForm.lastName.$valid = true
myForm.lastName.$error = {}
myForm.$valid = true
myForm.$error.required = false
myForm.$error.minlength = false
myForm.$error.maxlength = false
```

Required

- Use the HTML5 attribute required to specify that the input field must be filled out:

```
<form name="myForm">
<input name="myInput" ng-model="myInput" required>
</form>

<p>The input's valid state is:</p>
<h1>{{myForm.myInput.$valid}}</h1>
```

E-mail

- Use the HTML5 type email to specify that the value must be an e-mail:

```
<form name="myForm">
<input name="myInput" ng-model="myInput" type="email">
</form>

<p>The input's valid state is:</p>
<h1>{{myForm.myInput.$valid}}</h1>
```

Form State and Input State

- AngularJS is constantly updating the state of both the form and the input fields.
- Input fields have the following states:
  - $untouched The field has not been touched yet
  - $touched The field has been touched
  - $pristine The field has not been modified yet
  - $dirty The field has been modified
  - $invalid The field content is not valid
  - $valid The field content is valid
- They are all properties of the input field, and are either true or false.

CSS Classes

- AngularJS adds CSS classes to forms and input fields depending on their states.
- The following classes are added to, or removed from, input fields:
  - ng-untouched The field has not been touched yet
  - ng-touched The field has been touched
  - ng-pristine The field has not been  modified yet
  - ng-dirty The field has been modified
  - ng-valid The field content is valid
  - ng-invalid The field content is not valid
  - ng-valid-key One key for each validation. Example: ng-valid-required, useful when there are more than one thing that must be validated
  - ng-invalid-key Example: ng-invalid-required

- The following classes are added to, or removed from, forms:
  - ng-pristine No fields has not been modified yet
  - ng-dirty One or more fields has been modified
  - ng-valid The form content is valid
  - ng-invalid The form content is not valid
  - ng-valid-key One key for each validation. Example: ng-valid-required, useful when there are more than one thing that must be validated
  - ng-invalid-key Example: ng-invalid-required
- The classes are removed if the value they represent is false.

```
<style>
input.ng-invalid {
    background-color: pink;
}
input.ng-valid {
    background-color: lightgreen;
}
</style>
```



# Standard Directives and Filters evaluates knowledge of the directives (ng-class, ng-if, ng-bind, ng-repeat, ng-switch) and filters (ng-filter, ng-order, ng-currency) included in core AngularJS.


ng-class

- The ngClass directive allows you to dynamically set CSS classes on an HTML element by databinding an expression that represents all classes to be added.
- The ng-class directive dynamically binds one or more CSS classes to an HTML element.
- he value of the ng-class directive can be a string, an object, or an array.
- If it is a string, it should contain one or more, space-separated class names.
- As an object, it should contain key-value pairs, where the key is the class name of the class you want to add, and the value is a boolean value. The class will only be added if the value is set to true.
- As an array, it can be a combination of both. Each array element can be either a string, or an object, described as above.

```
<element ng-class="expression"></element>
```

- expression  An expression that returns one or more class names.

```
<div ng-class="[styleOne, styleTwo]">Look! I'm Words!</div>
```

ng-if

- The ng-if directive removes the HTML element if the expression evaluates to false.
- If the if statement evaluates to true, a copy of the Element is added in the DOM.
- The ng-if directive is different from the ng-hide, which hides the display of the element, where the ng-if directive completely removes the element from the DOM.
- Uncheck a checkbox to remove a section:

```
Keep HTML: <input type="checkbox" ng-model="myVar" ng-init="myVar = true">
<div ng-if="myVar">
<h1>Welcome</h1>
<p>Welcome to my home.</p>
<hr>
</div>
```

ng-bind

- The ngBind attribute tells Angular to replace the text content of the specified HTML element with the value of a given expression, and to update the text content when the value of that expression changes.
- Typically, you don't use ngBind directly, but instead you use the double curly markup like {{ expression }} which is similar but less verbose.

```
<script>
  angular.module('bindExample', [])
    .controller('ExampleController', ['$scope', function($scope) {
      $scope.name = 'Whirled';
    }]);
</script>
<div ng-controller="ExampleController">
  <label>Enter name: <input type="text" ng-model="name"></label><br>
  Hello <span ng-bind="name"></span>!
</div>
```

ng-repeat

- The ng-repeat directive repeats a set of HTML, a given number of times.
- The set of HTML will be repeated once per item in a collection.
- The collection must be an array or an object.

```
controller="myCtrl">
<h1 ng-repeat="x in records">{{x}}</h1>

<script>
var app = angular.module("myApp", []);
app.controller("myCtrl", function($scope) {
    $scope.records = [
        "Alfreds Futterkiste",
        "Berglunds snabbköp",
        "Centro comercial Moctezuma",
        "Ernst Handel",
    ]
});
</script>
```

ng-switch

- Show a section of HTML, only if it matches a certain value:
- Child elements with the ng-switch-when directive will be displayed if it gets a match, otherwise the element, and its children will be removed.
- You can also define a default section, by using the ng-switch-default directive, to show a section if non of the other sections get a match.

```
<div ng-switch="myVar">
  <div ng-switch-when="dogs">
    <h1>Dogs</h1>
    <p>Welcome to a world of dogs.</p>
  </div>
  <div ng-switch-when="tuts">
    <h1>Tutorials</h1>
    <p>Learn from examples.</p>
  </div>
  <div ng-switch-when="cars">
    <h1>Cars</h1>
    <p>Read about cars.</p>
  </div>
  <div ng-switch-default>
    <h1>Switch</h1>
    <p>Select topic from the dropdown, to switch the content of this DIV.</p>
  </div>
</div>
```


ng-filter

- Filters are used for formatting data displayed to the user.

```
{{ expression [| filter_name[:parameter_value] ... ] }}
```

```
$filter(name);
```

- name  String
  - Name of the filter function to retrieve


```
<div ng-controller="MainCtrl">
 <h3>{{ originalText }}</h3>
 <h3>{{ filteredText }}</h3>
</div>

angular.module('filterExample', [])
.controller('MainCtrl', function($scope, $filter) {
  $scope.originalText = 'hello';
  $scope.filteredText = $filter('uppercase')($scope.originalText);
});
```

ng-orderBy

- The orderBy filter allows us to sort an array.
- By default, strings are sorted alphabetically, and numbers are sorted numerically.


```
{{ array | orderBy : expression : reverse }}
```

- expression
  - The expression used to determine the order. The expression can be of type:
  - String: If the array is an array of objects, you can sort the array by the value of one of the object properties. See the examples below.
  - Function: You can create a function to organize the sorting.
  - Array: Use an array if you need more than one object property to determine the sorting order. The array items can be both strings and functions.
- reverse
  - Optional. Set to true if you want to reverse the order of the array.

```
<ul>
<li ng-repeat="x in customers | orderBy : 'city'">{{x.name + ", " + x.city}}</li>
</ul>
```

Descending Order:

```
<ul>
<li ng-repeat="x in customers | orderBy : '-city'">{{x.name + ", " + x.city}}</li>
</ul>
```

ng-currency

```
{{ currency_expression | currency : symbol : fractionSize}}
```

- symbol (optional) string
  - Currency symbol or identifier to be displayed.
- fractionSize (optional) number
  - Number of decimal places to round the amount to, defaults to default max fraction size for current locale

```
<span id="currency-default">{{amount | currency}}</span><br>
  custom currency identifier (USD$): <span id="currency-custom">{{amount | currency:"USD$"}}</span><br>
  no fractions (0): <span id="currency-no-fractions">{{amount | currency:"USD$":0}}</span>
  ```




